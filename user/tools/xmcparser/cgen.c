/*
 * $FILE: cgen.c
 *
 * Dumps the information in C format
 *
 * $VERSION$
 *
 * Authors: Miguel Masmano <mmasmano@fentiss.com>
 *
 * $LICENSE:
 * COPYRIGHT (c) Fent Innovative Software Solutions S.L.
 *     Read LICENSE.txt file for the license terms.
 */
/*
 * Changelog:
 * - [09/02/16:XM-ARM-2:SPR-151125-01:#97] Add a member in xmcHyp to contain Hypervisor Features.
 */

#include <xm_inc/linkage.h>
#include <stdio.h>
#include <xm_inc/arch/paging.h>
#include <xm_inc/arch/asm_offsets.h>
#include <xm_inc/guest.h>
#include "common.h"
#include "xmc.h"

#define XMC_C_HEADER "/* File generated by xmcparser. Don't modify. */\n\n" \
                     "#include <xm_inc/xmconf.h>\n\n"

#define PRINT_PREF

static inline void GenerateHm(FILE *oFile, struct xmcHmSlot *hmTab) {
    extern char *hmActions[];
    extern char *hmEvents[];
    extern char *hmLog[];
    int i;

    fprintf(oFile, ADDNTAB(1, ".hmTab = {\n"));
    for (i=0; i<XM_HM_MAX_EVENTS; i++)
        if (hmEvents[i])
            fprintf(oFile, ADDNTAB(2, "[%s] = {.action = %s, .log = %s },\n"), hmEvents[i], hmActions[hmTab[i].action], hmLog[hmTab[i].log]);

    fprintf(oFile, ADDNTAB(1, "},\n"));
}
#pragma GCC diagnostic ignored "-Woverflow"
static inline void GenerateRegionTab(FILE *oFile) {
    int e;
    fprintf(oFile, "const struct xmcMemoryRegion xmcMemRegTab[] = {\n");
    
    for (e=0; e<xmc.noRegions; e++) {
		fprintf(oFile, 
			ADDNTAB(1, "[%d] = {\n")
			ADDNTAB(2, ".startAddr = 0x%"PRINT_PREF"x,\n")
			ADDNTAB(2, ".size = %"PRINT_PREF"u,\n")
			ADDNTAB(2, ".flags = 0x%x,\n")
			ADDNTAB(1, "},\n"),
			e, xmcMemRegTab[e].startAddr, xmcMemRegTab[e].size, (xmcMemRegTab[e].flags&(XM_MEM_AREA_FLAGS_MASK)));
    }
    
    fprintf(oFile, "};\n\n");
}

static inline void GeneratePhysMemAreaTab(FILE *oFile) {
    int i;
    fprintf(oFile, "const struct xmcMemoryArea xmcPhysMemAreaTab[] = {\n");
    for (i=0; i<xmc.noPhysicalMemoryAreas; i++) {
	fprintf(oFile, ADDNTAB(1, "[%d] = {\n"), i);
        fprintf(oFile, ADDNTAB(2, ".nameOffset = %u,\n"),  xmcMemAreaTab[i].nameOffset);
	fprintf(oFile, ADDNTAB(2, ".startAddr = 0x%"PRINT_PREF"x,\n"),  xmcMemAreaTab[i].startAddr);
        fprintf(oFile, ADDNTAB(2, ".mappedAt = 0x%"PRINT_PREF"x,\n"),  xmcMemAreaTab[i].mappedAt);
	fprintf(oFile, ADDNTAB(2, ".size = %"PRINT_PREF"u,\n"), xmcMemAreaTab[i].size);
	fprintf(oFile, ADDNTAB(2, ".flags = 0x%x,\n"), (xmcMemAreaTab[i].flags&(XM_MEM_AREA_FLAGS_MASK)));
        fprintf(oFile, ADDNTAB(2, ".memoryRegionOffset = 0x%x,\n"), xmcMemAreaTab[i].memoryRegionOffset);
	fprintf(oFile, ADDNTAB(1, "},\n"));
    }
    fprintf(oFile, "};\n\n");
}

#if defined(CONFIG_MPU) && defined(CONFIG_AT697F)
static inline void GenerateSharedMemAreaTab(FILE *oFile) {
    int i;
    fprintf(oFile, "const struct xmcSharedMemoryArea xmcSharedMemAreaTab[] = {\n");
    for (i=0; i<xmc.hpv.noSharedMemoryAreas; i++)
    {
        fprintf(oFile, ADDNTAB(1, "[%d] = {\n"), i);
        fprintf(oFile, ADDNTAB(2, ".startAddr = 0x%"PRINT_PREF"x,\n"),  xmcSharedMemAreaTab[i].startAddr);
        fprintf(oFile, ADDNTAB(2, ".size = %"PRINT_PREF"u,\n"), xmcSharedMemAreaTab[i].size);
        fprintf(oFile, ADDNTAB(1, "},\n"));
    }
    fprintf(oFile, "};\n\n");
}
#endif

static inline void GenerateCyclicSlots(FILE *oFile) {
    int j;
    fprintf(oFile, "const struct xmcSchedCyclicSlot xmcSchedCyclicSlotTab[] = {\n");
    for(j=0; j<xmc.noSchedCyclicSlots; j++) {
	fprintf(oFile,
		ADDNTAB(1, "[%d] = {\n")
		ADDNTAB(2, ".id = 0x%x,\n")
		ADDNTAB(2, ".partitionId = %d,\n")
                ADDNTAB(2, ".vCpuId = %d,\n")
		ADDNTAB(2, ".sExec = %d,\n")
		ADDNTAB(2, ".eExec = %d,\n")
                ADDNTAB(2, ".flags = 0x%x,\n")
		ADDNTAB(1, "},\n"),
		j, xmcSchedCyclicSlotTab[j].id, xmcSchedCyclicSlotTab[j].partitionId, xmcSchedCyclicSlotTab[j].vCpuId, xmcSchedCyclicSlotTab[j].sExec, xmcSchedCyclicSlotTab[j].eExec, xmcSchedCyclicSlotTab[j].flags);
    }	
    fprintf(oFile, "};\n\n");
    
}
static inline void GenerateCyclicPlans(FILE *oFile) {
    int j;
    fprintf(oFile, "const struct xmcSchedCyclicPlan xmcSchedCyclicPlanTab[] = {\n");
    for(j=0; j<xmc.noSchedCyclicPlans; j++) {
	fprintf(oFile,
		ADDNTAB(1, "[%d] = {\n")
                ADDNTAB(2, ".nameOffset = %d,\n")
		ADDNTAB(2, ".id = 0x%x,\n")
		ADDNTAB(2, ".majorFrame = %u,\n")
#ifdef CONFIG_PLAN_EXTSYNC
                ADDNTAB(2, ".extSync = %d,\n")
#endif
		ADDNTAB(2, ".noSlots = %d,\n")
		ADDNTAB(2, ".slotsOffset = %d,\n")
		ADDNTAB(1, "},\n"),
		j, xmcSchedCyclicPlanTab[j].nameOffset, xmcSchedCyclicPlanTab[j].id, xmcSchedCyclicPlanTab[j].majorFrame, 
#ifdef CONFIG_PLAN_EXTSYNC
                xmcSchedCyclicPlanTab[j].extSync, 
#endif
                xmcSchedCyclicPlanTab[j].noSlots, xmcSchedCyclicPlanTab[j].slotsOffset);
    }	
    fprintf(oFile, "};\n\n");
    
}


static inline void GenerateDev(FILE *oFile, char name[], xmDev_t *dev) {
    fprintf(oFile, ADDNTAB(1, ".%s = { .id= 0x%x, .subId = 0x%x,},\n"), name, dev->id, dev->subId);
}

/*static inline void GenerateTrace(FILE *oFile, struct xmcTrace *trace) {
    fprintf(oFile, ADDNTAB(1, ".trace = {\n"));
    GenerateDev(oFile, "dev", &trace->dev);
    //fprintf(oFile, ADDNTAB(2, ".bitmap = 0x%x,\n"), trace->bitmap);
    fprintf(oFile, ADDNTAB(1, "},\n"));
}
*/
static inline void GenerateCommChannelTab(FILE *oFile) {
    int e;
    fprintf(oFile, "const struct xmcCommChannel xmcCommChannelTab[] = {\n");
    
    for (e=0; e<xmc.noCommChannels; e++) {
	fprintf(oFile,
		ADDNTAB(1, "[%d] = {\n")
		ADDNTAB(2, ".type = "),	e);
	
	switch(xmcCommChannelTab[e].type) {
	case XM_SAMPLING_CHANNEL:
	    fprintf(oFile,
		    "XM_SAMPLING_CHANNEL,\n"
		    ADDNTAB(2, "{.s.maxLength = %d,\n")
		    ADDNTAB(2, ".s.refreshPeriod = %u,\n")                    
                    ADDNTAB(2, ".s.address = 0x%x,\n")
                    ADDNTAB(2, ".s.size = %u,\n")
                    ADDNTAB(2, ".s.noReceivers = %d, },\n"),
		    xmcCommChannelTab[e].s.maxLength,
		    xmcCommChannelTab[e].s.refreshPeriod,
                    xmcCommChannelTab[e].s.address,
                    xmcCommChannelTab[e].s.size,
                    xmcCommChannelTab[e].s.noReceivers
                );
	    break;
	case XM_QUEUING_CHANNEL:
	    fprintf(oFile,
		    "XM_QUEUING_CHANNEL,\n"
		    ADDNTAB(2, "{.q.maxLength = %d,\n")
                    ADDNTAB(2, ".q.maxTimeExpiration = %u,\n")
                    ADDNTAB(2, ".q.address = 0x%x,\n")
                    ADDNTAB(2, ".q.size = %u,\n")
		    ADDNTAB(2, ".q.maxNoMsgs = %d, },\n"), 
                    xmcCommChannelTab[e].q.maxLength, 
                    xmcCommChannelTab[e].q.maxTimeExpiration, 
                    xmcCommChannelTab[e].q.address,
                    xmcCommChannelTab[e].q.size,
                    xmcCommChannelTab[e].q.maxNoMsgs);
	    break;
	}
	
	fprintf(oFile, ADDNTAB(1, "},\n"));
    }
    
    fprintf(oFile, "};\n\n");
}

static inline void GenerateCommPortTab(FILE *oFile) {
    int e;
    fprintf(oFile, "const struct xmcCommPort xmcCommPorts[] = {\n");
    for (e=0; e<xmc.noCommPorts; e++) {
	fprintf(oFile,
	    	ADDNTAB(1, "[%d] = {\n")
	    	ADDNTAB(2, ".nameOffset = %d,\n")
		ADDNTAB(2, ".channelId = "),
		e, xmcCommPortTab[e].nameOffset);
	
	if (xmcCommPortTab[e].channelId==XM_NULL_CHANNEL) {
	    fprintf(oFile, "XM_NULL_CHANNEL, \n");
	} else {
	    fprintf(oFile,
		    "%d, \n", xmcCommPortTab[e].channelId);
	}
	
	fprintf(oFile, ADDNTAB(2, ".direction = "));
	
	switch(xmcCommPortTab[e].direction) {
	case XM_SOURCE_PORT:
	    fprintf(oFile, "XM_SOURCE_PORT, \n");
	    break;
	case XM_DESTINATION_PORT:
	    fprintf(oFile, "XM_DESTINATION_PORT, \n");
	    break;
	}
	
	fprintf(oFile, ADDNTAB(2, ".type = "));
	switch(xmcCommPortTab[e].type) {
	case XM_SAMPLING_PORT:
	    fprintf(oFile, "XM_SAMPLING_PORT, \n");
	    break;
	case XM_QUEUING_PORT:
	    fprintf(oFile, "XM_QUEUING_PORT, \n");
	    break;
	}
        fprintf(oFile, ADDNTAB(2, ".flags = 0x%x, \n"), xmcCommPortTab[e].flags);
        fprintf(oFile, ADDNTAB(2, ".cpuId = %u, \n"), xmcCommPortTab[e].cpuId);
	fprintf(oFile, ADDNTAB(1, "},\n"));
    }
    fprintf(oFile, "};\n\n");
}

static inline void GenerateIpviTab(FILE *oFile) {
    int e;
    fprintf(oFile, "const xm_u8_t xmcIpviDstTab[] = { ");
    for (e=0; e<xmc.noIpviDsts; e++)
        fprintf(oFile, "%d, ", ipviDstTab[e]);
    fprintf(oFile, "};\n\n");
}

static inline void GenerateHpv(FILE *oFile) {
    int e;
    fprintf(oFile, ADDNTAB(1, ".hpv = {\n"));
    fprintf(oFile, ADDNTAB(2, ".noPhysicalMemoryAreas = %d,\n"), xmc.hpv.noPhysicalMemoryAreas);    
    fprintf(oFile, ADDNTAB(2, ".physicalMemoryAreasOffset = %d,\n"),
    xmc.hpv.physicalMemoryAreasOffset);

#if defined(CONFIG_MPU) && defined(CONFIG_AT697F)
    fprintf(oFile, ADDNTAB(2, ".sharedMemoryAreasOffset = %d,\n"),
    xmc.hpv.sharedMemoryAreasOffset);
    fprintf(oFile, ADDNTAB(2, ".noSharedMemoryAreas = %d,\n"),
    xmc.hpv.noSharedMemoryAreas);
#endif
    
    fprintf(oFile, ADDNTAB(2, ".noCpus = %d,\n")
	    ADDNTAB(2, ".cpuTab = {\n"), xmc.hpv.noCpus);

    for (e=0; e<xmc.hpv.noCpus; e++) {
        fprintf(oFile,
                ADDNTAB(3, "[%d] = {\n")
                ADDNTAB(4, ".id = %d,\n")
                ADDNTAB(4, ".features = 0x%x,\n")
                ADDNTAB(4, ".freq = "), e, xmc.hpv.cpuTab[e].id, xmc.hpv.cpuTab[e].features);
        
        if (!xmc.hpv.cpuTab[e].freq)
            fprintf(oFile, "XM_CPUFREQ_AUTO,\n");
        else
            fprintf(oFile, "%u,\n",xmc.hpv.cpuTab[e].freq);
        fprintf(oFile, ADDNTAB(4, ".schedCyclicPlansOffset = %d,\n")
                ADDNTAB(4, ".noSchedCyclicPlans = %d,\n"),
                xmc.hpv.cpuTab[e].schedCyclicPlansOffset,
                xmc.hpv.cpuTab[e].noSchedCyclicPlans
            );
        GenerateDev(oFile, "consoleDev", &xmc.hpv.cpuTab[e].consoleDev);
	fprintf(oFile, ADDNTAB(3, "},\n"));
    }
    
    fprintf(oFile,
	    ADDNTAB(2, "},\n"));
    GenerateHm(oFile, xmc.hpv.hmTab);
    fprintf(oFile,
	    ADDNTAB(2, ".hwIrqTab = {\n"));
    
    for (e=0; e<CONFIG_NO_HWIRQS; e++) {
		fprintf(oFile, ADDNTAB(3, "[%d] = {.owner = "), e);
		
		if (xmc.hpv.hwIrqTab[e].owner==XM_IRQ_NO_OWNER)
		    fprintf(oFile, "XM_IRQ_NO_OWNER, },\n");
		else
		    fprintf(oFile, "%d, },\n", xmc.hpv.hwIrqTab[e].owner);
    }
    fprintf(oFile, ADDNTAB(2, "},\n"));
    //GenerateTrace(oFile, &xmc.hpv.trace);
    GenerateDev(oFile, "consoleDev", &xmc.hpv.consoleDev);
    //GenerateDev(oFile, "hmDev", &xmc.hpv.hmDev);
    fprintf(oFile , ADDNTAB(1, ".hypFeatures = 0x%x,\n"), xmc.hpv.hypFeatures);
    fprintf(oFile, ADDNTAB(1, "},\n")); 
}

static inline void GenerateRsw(FILE *oFile) {
    fprintf(oFile, ADDNTAB(1, ".rsw = {\n"));
    fprintf(oFile, ADDNTAB(2, ".noPhysicalMemoryAreas = %d,\n"), xmc.rsw.noPhysicalMemoryAreas);
    fprintf(oFile, ADDNTAB(2, ".physicalMemoryAreasOffset = %d,\n"), xmc.rsw.physicalMemoryAreasOffset);
    fprintf(oFile, ADDNTAB(2, ".entryPoint = 0x%"PRINT_PREF"x,\n"), xmc.rsw.entryPoint);
    fprintf(oFile, ADDNTAB(1, "},\n"));
}

static inline void GeneratePartitionTab(FILE *oFile) {
    int e, i, o;

#ifndef CONFIG_ARM
    fprintf(oFile, "struct xmcBootPart xmcBootPartitionTab[%d];\n", xmc.noPartitions);
#else
    fprintf(oFile, "struct xmcBootPart xmcBootPartitionTab[%d]={\n", xmc.noPartitions);
    for (e=0; e<xmc.noPartitions; e++)
        fprintf(oFile,
		ADDNTAB(1, "[%d] = {.flags=0xff000000},\n"), e);
    fprintf(oFile, "};\n");
#endif

    fprintf(oFile, "const struct xmcPartition xmcPartitionTab[] = {\n");
    for (e=0; e<xmc.noPartitions; e++) {
	fprintf(oFile,
		ADDNTAB(1, "[%d] = {\n")
		ADDNTAB(2, ".id = %d,\n")
                ADDNTAB(2, ".rId = %d,\n")
		ADDNTAB(2, ".nameOffset = %d,\n")
		ADDNTAB(2, ".flags = 0x%x,\n"),
		e, xmcPartitionTab[e].id, xmcPartitionTab[e].rId, xmcPartitionTab[e].nameOffset, xmcPartitionTab[e].flags);
        /*TOBEAPPROVED: ARMPorting: */
        fprintf(oFile, ADDNTAB(2, ".hwIrqs = {"));
       	for(o=0;o<(CONFIG_NO_HWIRQS-1);o++)
       	{	fprintf(oFile, "0x%x, ", xmcPartitionTab[e].hwIrqs[o]); }
   		fprintf(oFile, "0x%x},\n", xmcPartitionTab[e].hwIrqs[CONFIG_NO_HWIRQS-1]);
	GenerateDev(oFile, "consoleDev", &xmcPartitionTab[e].consoleDev);
	fprintf(oFile,
		ADDNTAB(2, ".temporalRestrictions = {.period = %u, .duration = %u},\n")
		ADDNTAB(2, ".noPhysicalMemoryAreas = %d,\n")
		ADDNTAB(2, ".physicalMemoryAreasOffset = %d,\n"),
		xmcPartitionTab[e].temporalRestrictions.period, xmcPartitionTab[e].temporalRestrictions.duration, xmcPartitionTab[e].noPhysicalMemoryAreas, xmcPartitionTab[e].physicalMemoryAreasOffset);
	GenerateHm(oFile, xmcPartitionTab[e].hmTab);
	fprintf(oFile,
		ADDNTAB(2, ".noPorts = %d,\n")
		ADDNTAB(2, ".commPortsOffset = %d,\n"), xmcPartitionTab[e].noPorts,
		xmcPartitionTab[e].commPortsOffset);
        
	fprintf(oFile, ADDNTAB(2, ".ioPortsOffset = %d,\n"), xmcPartitionTab[e].ioPortsOffset);	
	fprintf(oFile, ADDNTAB(2, ".noIoPorts = %d,\n"), xmcPartitionTab[e].noIoPorts);
	fprintf(oFile, ADDNTAB(2, ".apbDevices = 0x%x,\n"), xmcPartitionTab[e].apbDevices);
        //GenerateTrace(oFile, &xmcPartitionTab[e].trace);
        fprintf(oFile, ADDNTAB(2, ".ipviTab = {\n"));
        for (i=0; i<CONFIG_MAX_NO_IPVI; i++) {
            fprintf(oFile, ADDNTAB(3, "[%d] = {\n"), i);
            fprintf(oFile, ADDNTAB(4, ".dstOffset = %d,\n"), xmcPartitionTab[e].ipviTab[i].dstOffset);
            fprintf(oFile, ADDNTAB(4, ".noDsts = %d,\n"), xmcPartitionTab[e].ipviTab[i].noDsts);
            fprintf(oFile, ADDNTAB(3, "},\n"));
        }
        fprintf(oFile, ADDNTAB(2, "},\n"));
	fprintf(oFile, ADDNTAB(1, "},\n"));
    }
    fprintf(oFile, "};\n\n");
}

static inline void GenerateStringTab(FILE *oFile) {
    int i;
    /* String Table */
    fprintf(oFile, "const char xmcStringTab[] = {");
    for (i=0; i<xmc.stringTabLength; i++)
	fprintf(oFile, ADDNTAB(1, "0x%x, "), strTab[i]);
    fprintf(oFile, "};\n\n");
}

static inline void GenerateSystemDevices(FILE *oFile) {
#if defined(CONFIG_DEV_MEMBLOCK)||defined(CONFIG_DEV_MEMBLOCK_MODULE)
    int e;
    fprintf(oFile, "const struct xmcMemBlock xmcMemBlockTab[]={\n");
    
    for (e=0; e<xmc.deviceTab.noMemBlocks; e++) {
	fprintf(oFile, ADDNTAB(1, "[%d] = {\n"), e);
        fprintf(oFile, ADDNTAB(2, ".physicalMemoryAreasOffset = %d,\n"), xmcMemBlockTab[e].physicalMemoryAreasOffset);
	fprintf(oFile, ADDNTAB(1, "},\n"));
    }    
    fprintf(oFile, "};\n\n");
#endif   
}

static inline void GenerateXMC(FILE *oFile) {
    int e;
    fprintf(oFile, "const struct xmc xmc __attribute__ ((section(\".rodata.hdr\"))) = {\n"
	    ADDNTAB(1, ".signature = XMC_SIGNATURE,\n")
            ADDNTAB(1, ".dataSize = (xmSize_t)_dataSize,\n")
            ADDNTAB(1, ".size = (xmSize_t)_xmcSize,\n")
	    ADDNTAB(1, ".version = XMC_SET_VERSION(%d, %d, %d),\n")
	    ADDNTAB(1, ".fileVersion = XMC_SET_VERSION(%d, %d, %d),\n")	    
	    ADDNTAB(1, ".rsvMemTabOffset = (xmAddress_t)_memObjTab,\n")
	    ADDNTAB(1, ".nameOffset = %"PRINT_PREF"d,\n"),
	    XMC_VERSION, XMC_SUBVERSION, XMC_REVISION, XMC_GET_VERSION(xmc.fileVersion), XMC_GET_SUBVERSION(xmc.fileVersion), XMC_GET_REVISION(xmc.fileVersion), xmc.nameOffset);
    GenerateHpv(oFile);
    GenerateRsw(oFile);
    fprintf(oFile, ADDNTAB(1, ".partitionTabOffset = (xmAddress_t)xmcPartitionTab,\n"));    
    fprintf(oFile,
	    ADDNTAB(1, ".noPartitions = %d,\n"), xmc.noPartitions);

    fprintf(oFile, ADDNTAB(1, ".bootPartitionTabOffset = (xmAddress_t)xmcBootPartitionTab,\n"));

    fprintf(oFile,
	    ADDNTAB(1, ".memoryRegionsOffset = (xmAddress_t)xmcMemRegTab,\n")
	    ADDNTAB(1, ".noRegions = %d,\n"), xmc.noRegions);

    fprintf(oFile,
        ADDNTAB(1, ".physicalMemoryAreasOffset = (xmAddress_t)xmcPhysMemAreaTab,\n")
        ADDNTAB(1, ".noPhysicalMemoryAreas = %d,\n"), xmc.noPhysicalMemoryAreas);
    
#if defined(CONFIG_MPU) && defined(CONFIG_AT697F)
    fprintf(oFile,
        ADDNTAB(1, ".sharedMemoryAreasOffset = (xmAddress_t)xmcSharedMemAreaTab,\n")
        ADDNTAB(1, ".noSharedMemoryAreas = %d,\n"), xmc.hpv.noSharedMemoryAreas);
#endif
    
    fprintf(oFile, 
	    ADDNTAB(1, ".schedCyclicSlotsOffset = (xmAddress_t)xmcSchedCyclicSlotTab,\n")
	    ADDNTAB(1, ".noSchedCyclicSlots = %d,\n"), xmc.noSchedCyclicSlots);

    fprintf(oFile, 
	    ADDNTAB(1, ".schedCyclicPlansOffset = (xmAddress_t)xmcSchedCyclicPlanTab,\n")
	    ADDNTAB(1, ".noSchedCyclicPlans = %d,\n"), xmc.noSchedCyclicPlans);

    fprintf(oFile, 
	    ADDNTAB(1, ".commChannelTabOffset = (xmAddress_t)xmcCommChannelTab,\n")
	    ADDNTAB(1, ".noCommChannels = %d,\n"), xmc.noCommChannels);
    
    fprintf(oFile, 
	    ADDNTAB(1, ".commPortsOffset = (xmAddress_t)xmcCommPorts,\n")
	    ADDNTAB(1, ".noCommPorts = %d,\n"), xmc.noCommPorts);

    fprintf(oFile, 
	    ADDNTAB(1, ".ioPortsOffset = (xmAddress_t)xmcIoPortTab,\n")
	    ADDNTAB(1, ".noIoPorts = %d,\n"), xmc.noIoPorts);

    fprintf(oFile,
            ADDNTAB(1, ".ipviDstOffset = (xmAddress_t)xmcIpviDstTab,\n")
	    ADDNTAB(1, ".noIpviDsts = %d,\n"), xmc.noIpviDsts);
    
    fprintf(oFile,
	    ADDNTAB(1, ".vCpuTabOffset = (xmAddress_t)&xmcVCpuTab[0][0],\n"));
    fprintf(oFile, 
	    ADDNTAB(1, ".stringsOffset = (xmAddress_t)xmcStringTab,\n")
	    ADDNTAB(1, ".stringTabLength = %d,\n"), xmc.stringTabLength);

    fprintf(oFile, ADDNTAB(1, ".deviceTab = {\n"));
#if defined(CONFIG_DEV_MEMBLOCK)||defined(CONFIG_DEV_MEMBLOCK_MODULE)
    fprintf(oFile, ADDNTAB(2, ".memBlocksOffset = (xmAddress_t)xmcMemBlockTab,\n"));
    fprintf(oFile, ADDNTAB(2, ".noMemBlocks = %d,\n"), xmc.deviceTab.noMemBlocks);
#endif
#if defined(CONFIG_DEV_UART)||defined(CONFIG_DEV_UART_MODULE)
    fprintf(oFile, ADDNTAB(2, ".uart = {\n"));
    for (e=0; e<CONFIG_DEV_NO_UARTS; e++)
	
	fprintf(oFile, ADDNTAB(3, "[%d] = {.baudRate = %d, },\n"), e, xmc.deviceTab.uart[e].baudRate);
    fprintf(oFile, ADDNTAB(2, "},\n"));
#endif
    fprintf(oFile, ADDNTAB(1, "},\n"));
    fprintf(oFile, "};\n");
}

extern void ArchLdrRsvMem(FILE *oFile);

#ifdef CONFIG_MPU
extern void ArchMpuRsvMem(FILE *oFile);
#endif
#ifdef CONFIG_MMU
extern void ArchMmuRsvMem(FILE *oFile);
#endif

static void GenerateRsvMem(FILE *oFile) {
    int i, j;

    // Partitions
    RsvBlock(xmc.noPartitions*_PARTITION_T_SIZEOF, ALIGNMENT, "scheduler's partitions table");

    RsvBlock(xmc.noPartitions*CONFIG_NO_VCPUS*_KTHREAD_T_SIZEOF, ALIGNMENT, "kthreads");
    RsvBlock(xmc.noPartitions*CONFIG_NO_VCPUS*_STRUCT_GUEST_SIZEOF, ALIGNMENT, "vcpus");
    
    for (i=0; i<xmc.noCommChannels; i++) {
        if (xmcCommChannelTab[i].type==XM_SAMPLING_CHANNEL)
            if (xmcCommChannelTab[i].s.noReceivers) {
                RsvBlock(xmcCommChannelTab[i].s.noReceivers*_KTHREADPTR_T_SIZEOF, ALIGNMENT, "Sampling channel's receivers");
                RsvBlock(xmcCommChannelTab[i].s.noReceivers*sizeof(xm_s32_t), ALIGNMENT, "Sampling channel's receiver ports");
            }
    }

#ifdef CONFIG_MMU
    ArchMmuRsvMem(oFile);
#endif
    RsvBlock(_STRUCT_XMTRACEEVENT_SIZEOF*CONFIG_OBJ_TRACE_LOG_NO_ELEM, ALIGNMENT, "trace log structure"); // XM
    RsvBlock(_STRUCT_QUEUE_SIZEOF*xmc.noPartitions, ALIGNMENT, "trace log queues");
    for (i=0; i<xmc.noPartitions; i++)
        RsvBlock(_STRUCT_XMTRACEEVENT_SIZEOF*CONFIG_OBJ_TRACE_LOG_NO_ELEM, ALIGNMENT, "trace log structure"); // Logs

    RsvBlock(_STRUCT_XMHMLOG_SIZEOF*CONFIG_OBJ_HM_LOG_NO_ELEM, ALIGNMENT, "hm log structure"); // XM
    for (i=0; i<xmc.noPartitions; i++) {
        int pctSize=sizeof(partitionControlTable_t)+sizeof(struct xmPhysicalMemMap)*CONFIG_MAX_NO_MAREAS+(CONFIG_OBJ_MAX_NO_COMMPORTS>>XM_LOG2_WORD_SZ);
/*TBI:ARMPorting:#ifndef CONFIG_ARM*/
        RsvBlock(CONFIG_NO_VCPUS*pctSize, PTDL1ALIGN, "partition control tables");
/*TBI:ARMPorting:#else
        RsvNSBlock(CONFIG_NO_VCPUS*pctSize, PTDL1ALIGN, "partition control tables");
#endif*/
    }
    //RsvBlock(PAGE_SIZE, PAGE_SIZE, "partition control tables");        
#ifdef CONFIG_MPU
    ArchMpuRsvMem(oFile);
#endif
    //ArchLdrRsvMem(oFile);
#if defined(CONFIG_DEV_MEMBLOCK)||defined(CONFIG_DEV_MEMBLOCK_MODULE)
    // Memory Blocks
    RsvBlock(xmc.deviceTab.noMemBlocks*_KDEVICE_T_SIZEOF, ALIGNMENT, "memory block driver");
    RsvBlock(xmc.deviceTab.noMemBlocks*_STRUCT_MEMBLOCKDATA_SIZEOF, ALIGNMENT, "memory block driver");
#endif
    // Cyclic scheduler
    RsvBlock(xmc.hpv.noCpus*_STRUCT_SCHEDDATA_SIZEOF, ALIGNMENT, "scheduler data");

    // Console
    RsvBlock(xmc.noPartitions*_STRUCT_CONSOLE_SIZEOF, ALIGNMENT, "console object");

    // status    
    RsvBlock(xmc.noPartitions*_XMPARTITIONSTATUS_T_SIZEOF, ALIGNMENT, "status object");

    // trace
    //RsvBlock(xmc.noPartitions*_STRUCT_LOGSTREAM_SIZEOF, ALIGNMENT, "trace object");

    // comm ports
    RsvBlock(xmc.noCommChannels*_UNION_CHANNEL_SIZEOF, ALIGNMENT, "commport object");
    RsvBlock(xmc.noCommPorts*_STRUCT_PORT_SIZEOF, ALIGNMENT, "commport object");
    for (i=0; i<xmc.noCommChannels; i++)
	switch(xmcCommChannelTab[i].type) {
	case XM_SAMPLING_CHANNEL:
#ifdef CONFIG_AMP_SUPPORT
            if (!xmcCommChannelTab[i].s.address&&!xmcCommChannelTab[i].s.size) {
#ifdef NOT_IMPLEMENTED_YET
            RsvBlock(_STRUCT_CHANNELCTRLSAMPLING_SIZEOF+xmcCommChannelTab[i].s.maxLength, ALIGNMENT, "sampling commport ctrl");
#endif
            }
#endif
#ifdef CONFIG_SMP_SUPPORT
            RsvBlock(xmcCommChannelTab[i].s.maxLength*3, ALIGNMENT, "sampling commport object");
#else
            RsvBlock(xmcCommChannelTab[i].s.maxLength, ALIGNMENT, "sampling commport object");
#endif 
            break;
	case XM_QUEUING_CHANNEL:
#ifdef CONFIG_AMP_SUPPORT
            if (!xmcCommChannelTab[i].q.address&&!xmcCommChannelTab[i].q.size) {
#ifdef NOT_IMPLEMENTED_YET
            RsvBlock(_STRUCT_CHANNELCTRLQUEUING_SIZEOF+xmcCommChannelTab[i].q.maxNoMsgs*(_STRUCT_MSG_SIZEOF+xmcCommChannelTab[i].q.maxLength), ALIGNMENT, "queuing commport ctrl");
#endif
            }
#endif
            RsvBlock(xmcCommChannelTab[i].q.maxNoMsgs*_STRUCT_MSG_SIZEOF, ALIGNMENT, "queuing commport object");
            for (j=0; j<xmcCommChannelTab[i].q.maxNoMsgs; j++)
                RsvBlock(xmcCommChannelTab[i].q.maxLength, ALIGNMENT, "queuing commport object");
	    break;
	}
    
    PrintBlocks(oFile);
}

void GenerateVCpuTab(FILE *oFile) {
    int part, vcpu;
    fprintf(oFile, "const struct xmcVCpu xmcVCpuTab[%d][%d] = {\n",xmc.noPartitions, CONFIG_NO_VCPUS);
    for (part=0; part<xmc.noPartitions; part++) {
        fprintf(oFile, "{\n");
        for (vcpu=0;vcpu<CONFIG_NO_VCPUS;vcpu++)
            fprintf(oFile, ADDNTAB(1, "{.cpu = %d,},\n"), vCpuTab[part][vcpu].cpu);
        fprintf(oFile, "},\n");
    }
    fprintf(oFile, "};\n\n");
}

void GenerateCFile(FILE *oFile) {
    extern void GenerateIoPortTab(FILE *oFile);
    /* Header */
    fprintf(oFile, XMC_C_HEADER);
    fprintf(oFile, "extern char _xmcSize[];\n\n");
    fprintf(oFile, "extern char _dataSize[];\n\n");
    fprintf(oFile, "extern char _memObjTab[];\n\n");
    GenerateRegionTab(oFile);
    GeneratePhysMemAreaTab(oFile);
#if defined(CONFIG_MPU) && defined(CONFIG_AT697F)
    GenerateSharedMemAreaTab(oFile);
#endif
    GenerateCommChannelTab(oFile);
    GenerateCommPortTab(oFile);
    GenerateIpviTab(oFile);
    GenerateCyclicSlots(oFile);
    GenerateCyclicPlans(oFile);
    GenerateIoPortTab(oFile);
    GenerateStringTab(oFile);
    GenerateSystemDevices(oFile);
    GeneratePartitionTab(oFile);
    GenerateVCpuTab(oFile);
    GenerateXMC(oFile);
    GenerateRsvMem(oFile);
}
