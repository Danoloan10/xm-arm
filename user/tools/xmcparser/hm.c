/*
 * $FILE: hm.c
 *
 * health monitor management functions
 *
 * $VERSION$
 *
 * Authors: Miguel Masmano <mmasmano@fentiss.com>
 *
 * $LICENSE:
 * COPYRIGHT (c) Fent Innovative Software Solutions S.L.
 *     Read LICENSE.txt file for the license terms.
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "common.h"
#include "xmc.h"

#define FILL_TAB(x) [x]=#x

char *hmLog[2]={
    FILL_TAB(XM_HM_LOG_DISABLED),
    FILL_TAB(XM_HM_LOG_ENABLED),
};

char *hmActions[XM_HM_MAX_ACTIONS]={
    FILL_TAB(XM_HM_AC_IGNORE),
    FILL_TAB(XM_HM_AC_PARTITION_COLD_RESET),
    FILL_TAB(XM_HM_AC_PARTITION_WARM_RESET),
    FILL_TAB(XM_HM_AC_HYPERVISOR_COLD_RESET),
    FILL_TAB(XM_HM_AC_HYPERVISOR_WARM_RESET),
    FILL_TAB(XM_HM_AC_SUSPEND),
    FILL_TAB(XM_HM_AC_HALT),
    FILL_TAB(XM_HM_AC_PROPAGATE),
    FILL_TAB(XM_HM_AC_SWITCH_TO_MAINTENANCE),
};

char *hmEvents[XM_HM_MAX_EVENTS]={
    FILL_TAB(XM_HM_EV_INTERNAL_ERROR),
    FILL_TAB(XM_HM_EV_UNEXPECTED_TRAP),
    FILL_TAB(XM_HM_EV_PARTITION_UNRECOVERABLE),
    FILL_TAB(XM_HM_EV_PARTITION_ERROR),
    FILL_TAB(XM_HM_EV_PARTITION_INTEGRITY),
    FILL_TAB(XM_HM_EV_MEM_PROTECTION),
    FILL_TAB(XM_HM_EV_OVERRUN),
    FILL_TAB(XM_HM_EV_SCHED_ERROR),
    FILL_TAB(XM_HM_EV_WATCHDOG_TIMER),
    FILL_TAB(XM_HM_EV_INCOMPATIBLE_INTERFACE),
#ifdef CONFIG_ARM
    FILL_TAB(XM_HM_EV_ARM_UNDEF_INSTR),
    FILL_TAB(XM_HM_EV_ARM_PREFETCH_ABORT),
    FILL_TAB(XM_HM_EV_ARM_DATA_ABORT),
    FILL_TAB(XM_HM_EV_ARM_DATA_ALIGNMENT_FAULT),
    FILL_TAB(XM_HM_EV_ARM_DATA_BACKGROUND_FAULT),
    FILL_TAB(XM_HM_EV_ARM_DATA_PERMISSION_FAULT),
    FILL_TAB(XM_HM_EV_ARM_INSTR_ALIGNMENT_FAULT),
    FILL_TAB(XM_HM_EV_ARM_INSTR_BACKGROUND_FAULT),
    FILL_TAB(XM_HM_EV_ARM_INSTR_PERMISSION_FAULT),
#endif
};

xm_u32_t ToHmAction(char *s, int line) {
    int e;
    for (e=0; e<XM_HM_MAX_ACTIONS; e++)
	if (hmActions[e]&&!strcmp(s, hmActions[e]))
	    return e;
    
    LineError(line, "Expected a valid Health Monitor action");
    return 0;
}

xm_u32_t ToHmEvent(char *s, int line) {
     int e;
    for (e=0; e<XM_HM_MAX_EVENTS; e++)
	if (hmEvents[e]&&!strcmp(s, hmEvents[e]))
	    return e;
   
    LineError(line, "Expected a valid Health Monitor event");
    return 0;
}

#define TOBIT(x) (1<<x)

static xm_u32_t hmPartEventsAndActions[XM_HM_MAX_EVENTS]= {
    [XM_HM_EV_INTERNAL_ERROR]=TOBIT(XM_HM_AC_IGNORE)|TOBIT(XM_HM_AC_PARTITION_COLD_RESET)|TOBIT(XM_HM_AC_PARTITION_WARM_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_COLD_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_WARM_RESET)|TOBIT(XM_HM_AC_SUSPEND)|TOBIT(XM_HM_AC_HALT)|TOBIT(XM_HM_AC_SWITCH_TO_MAINTENANCE),

    [XM_HM_EV_UNEXPECTED_TRAP]=TOBIT(XM_HM_AC_IGNORE)|TOBIT(XM_HM_AC_PARTITION_COLD_RESET)|TOBIT(XM_HM_AC_PARTITION_WARM_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_COLD_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_WARM_RESET)|TOBIT(XM_HM_AC_SUSPEND)|TOBIT(XM_HM_AC_HALT)|TOBIT(XM_HM_AC_SWITCH_TO_MAINTENANCE),

    [XM_HM_EV_PARTITION_UNRECOVERABLE]=TOBIT(XM_HM_AC_IGNORE)|TOBIT(XM_HM_AC_PARTITION_COLD_RESET)|TOBIT(XM_HM_AC_PARTITION_WARM_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_COLD_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_WARM_RESET)|TOBIT(XM_HM_AC_SUSPEND)|TOBIT(XM_HM_AC_HALT)|TOBIT(XM_HM_AC_SWITCH_TO_MAINTENANCE),

    [XM_HM_EV_PARTITION_ERROR]=TOBIT(XM_HM_AC_IGNORE)|TOBIT(XM_HM_AC_PARTITION_COLD_RESET)|TOBIT(XM_HM_AC_PARTITION_WARM_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_COLD_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_WARM_RESET)|TOBIT(XM_HM_AC_SUSPEND)|TOBIT(XM_HM_AC_HALT)|TOBIT(XM_HM_AC_SWITCH_TO_MAINTENANCE),

    [XM_HM_EV_PARTITION_INTEGRITY]=TOBIT(XM_HM_AC_IGNORE)|TOBIT(XM_HM_AC_PARTITION_COLD_RESET)|TOBIT(XM_HM_AC_PARTITION_WARM_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_COLD_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_WARM_RESET)|TOBIT(XM_HM_AC_SUSPEND)|TOBIT(XM_HM_AC_HALT)|TOBIT(XM_HM_AC_SWITCH_TO_MAINTENANCE),

    [XM_HM_EV_MEM_PROTECTION]=TOBIT(XM_HM_AC_IGNORE)|TOBIT(XM_HM_AC_PARTITION_COLD_RESET)|TOBIT(XM_HM_AC_PARTITION_WARM_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_COLD_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_WARM_RESET)|TOBIT(XM_HM_AC_SUSPEND)|TOBIT(XM_HM_AC_HALT)|TOBIT(XM_HM_AC_SWITCH_TO_MAINTENANCE),

    [XM_HM_EV_OVERRUN]=TOBIT(XM_HM_AC_IGNORE)|TOBIT(XM_HM_AC_PARTITION_COLD_RESET)|TOBIT(XM_HM_AC_PARTITION_WARM_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_COLD_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_WARM_RESET)|TOBIT(XM_HM_AC_SUSPEND)|TOBIT(XM_HM_AC_HALT)|TOBIT(XM_HM_AC_SWITCH_TO_MAINTENANCE),

    [XM_HM_EV_SCHED_ERROR]=TOBIT(XM_HM_AC_IGNORE)|TOBIT(XM_HM_AC_PARTITION_COLD_RESET)|TOBIT(XM_HM_AC_PARTITION_WARM_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_COLD_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_WARM_RESET)|TOBIT(XM_HM_AC_SUSPEND)|TOBIT(XM_HM_AC_HALT)|TOBIT(XM_HM_AC_SWITCH_TO_MAINTENANCE),

    [XM_HM_EV_WATCHDOG_TIMER]=TOBIT(XM_HM_AC_IGNORE)|TOBIT(XM_HM_AC_PARTITION_COLD_RESET)|TOBIT(XM_HM_AC_PARTITION_WARM_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_COLD_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_WARM_RESET)|TOBIT(XM_HM_AC_SUSPEND)|TOBIT(XM_HM_AC_HALT)|TOBIT(XM_HM_AC_SWITCH_TO_MAINTENANCE),
    
    [XM_HM_EV_INCOMPATIBLE_INTERFACE]=TOBIT(XM_HM_AC_PARTITION_COLD_RESET)|TOBIT(XM_HM_AC_PARTITION_WARM_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_COLD_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_WARM_RESET)|TOBIT(XM_HM_AC_HALT)|TOBIT(XM_HM_AC_SWITCH_TO_MAINTENANCE),

#ifdef CONFIG_ARM
    [XM_HM_EV_ARM_UNDEF_INSTR]=TOBIT(XM_HM_AC_IGNORE)|TOBIT(XM_HM_AC_PARTITION_COLD_RESET)|TOBIT(XM_HM_AC_PARTITION_WARM_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_COLD_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_WARM_RESET)|TOBIT(XM_HM_AC_SUSPEND)|TOBIT(XM_HM_AC_HALT)|TOBIT(XM_HM_AC_PROPAGATE)|TOBIT(XM_HM_AC_SWITCH_TO_MAINTENANCE),
    [XM_HM_EV_ARM_PREFETCH_ABORT]=TOBIT(XM_HM_AC_IGNORE)|TOBIT(XM_HM_AC_PARTITION_COLD_RESET)|TOBIT(XM_HM_AC_PARTITION_WARM_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_COLD_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_WARM_RESET)|TOBIT(XM_HM_AC_SUSPEND)|TOBIT(XM_HM_AC_HALT)|TOBIT(XM_HM_AC_PROPAGATE)|TOBIT(XM_HM_AC_SWITCH_TO_MAINTENANCE),
    [XM_HM_EV_ARM_DATA_ABORT]=TOBIT(XM_HM_AC_IGNORE)|TOBIT(XM_HM_AC_PARTITION_COLD_RESET)|TOBIT(XM_HM_AC_PARTITION_WARM_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_COLD_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_WARM_RESET)|TOBIT(XM_HM_AC_SUSPEND)|TOBIT(XM_HM_AC_HALT)|TOBIT(XM_HM_AC_PROPAGATE)|TOBIT(XM_HM_AC_SWITCH_TO_MAINTENANCE),
    [XM_HM_EV_ARM_DATA_ALIGNMENT_FAULT]=TOBIT(XM_HM_AC_IGNORE)|TOBIT(XM_HM_AC_PARTITION_COLD_RESET)|TOBIT(XM_HM_AC_PARTITION_WARM_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_COLD_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_WARM_RESET)|TOBIT(XM_HM_AC_SUSPEND)|TOBIT(XM_HM_AC_HALT)|TOBIT(XM_HM_AC_PROPAGATE)|TOBIT(XM_HM_AC_SWITCH_TO_MAINTENANCE),
    [XM_HM_EV_ARM_DATA_BACKGROUND_FAULT]=TOBIT(XM_HM_AC_IGNORE)|TOBIT(XM_HM_AC_PARTITION_COLD_RESET)|TOBIT(XM_HM_AC_PARTITION_WARM_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_COLD_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_WARM_RESET)|TOBIT(XM_HM_AC_SUSPEND)|TOBIT(XM_HM_AC_HALT)|TOBIT(XM_HM_AC_PROPAGATE)|TOBIT(XM_HM_AC_SWITCH_TO_MAINTENANCE),
    [XM_HM_EV_ARM_DATA_PERMISSION_FAULT]=TOBIT(XM_HM_AC_IGNORE)|TOBIT(XM_HM_AC_PARTITION_COLD_RESET)|TOBIT(XM_HM_AC_PARTITION_WARM_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_COLD_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_WARM_RESET)|TOBIT(XM_HM_AC_SUSPEND)|TOBIT(XM_HM_AC_HALT)|TOBIT(XM_HM_AC_PROPAGATE)|TOBIT(XM_HM_AC_SWITCH_TO_MAINTENANCE),
    [XM_HM_EV_ARM_INSTR_ALIGNMENT_FAULT]=TOBIT(XM_HM_AC_IGNORE)|TOBIT(XM_HM_AC_PARTITION_COLD_RESET)|TOBIT(XM_HM_AC_PARTITION_WARM_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_COLD_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_WARM_RESET)|TOBIT(XM_HM_AC_SUSPEND)|TOBIT(XM_HM_AC_HALT)|TOBIT(XM_HM_AC_PROPAGATE)|TOBIT(XM_HM_AC_SWITCH_TO_MAINTENANCE),
    [XM_HM_EV_ARM_INSTR_BACKGROUND_FAULT]=TOBIT(XM_HM_AC_IGNORE)|TOBIT(XM_HM_AC_PARTITION_COLD_RESET)|TOBIT(XM_HM_AC_PARTITION_WARM_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_COLD_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_WARM_RESET)|TOBIT(XM_HM_AC_SUSPEND)|TOBIT(XM_HM_AC_HALT)|TOBIT(XM_HM_AC_PROPAGATE)|TOBIT(XM_HM_AC_SWITCH_TO_MAINTENANCE),
    [XM_HM_EV_ARM_INSTR_PERMISSION_FAULT]=TOBIT(XM_HM_AC_IGNORE)|TOBIT(XM_HM_AC_PARTITION_COLD_RESET)|TOBIT(XM_HM_AC_PARTITION_WARM_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_COLD_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_WARM_RESET)|TOBIT(XM_HM_AC_SUSPEND)|TOBIT(XM_HM_AC_HALT)|TOBIT(XM_HM_AC_PROPAGATE)|TOBIT(XM_HM_AC_SWITCH_TO_MAINTENANCE),
#endif
};


static xm_u32_t hmHpvEventsAndActions[XM_HM_MAX_EVENTS]= {
    [XM_HM_EV_INTERNAL_ERROR]=TOBIT(XM_HM_AC_IGNORE)|TOBIT(XM_HM_AC_HYPERVISOR_COLD_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_WARM_RESET)|TOBIT(XM_HM_AC_HALT)|TOBIT(XM_HM_AC_SWITCH_TO_MAINTENANCE),

    [XM_HM_EV_UNEXPECTED_TRAP]=TOBIT(XM_HM_AC_IGNORE)|TOBIT(XM_HM_AC_HYPERVISOR_COLD_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_WARM_RESET)|TOBIT(XM_HM_AC_HALT)|TOBIT(XM_HM_AC_SWITCH_TO_MAINTENANCE),

    [XM_HM_EV_PARTITION_UNRECOVERABLE]=TOBIT(XM_HM_AC_IGNORE)|TOBIT(XM_HM_AC_HYPERVISOR_COLD_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_WARM_RESET)|TOBIT(XM_HM_AC_HALT)|TOBIT(XM_HM_AC_SWITCH_TO_MAINTENANCE),

    [XM_HM_EV_PARTITION_ERROR]=TOBIT(XM_HM_AC_IGNORE)|TOBIT(XM_HM_AC_HYPERVISOR_COLD_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_WARM_RESET)|TOBIT(XM_HM_AC_HALT)|TOBIT(XM_HM_AC_SWITCH_TO_MAINTENANCE),

    [XM_HM_EV_PARTITION_INTEGRITY]=TOBIT(XM_HM_AC_IGNORE)|TOBIT(XM_HM_AC_HYPERVISOR_COLD_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_WARM_RESET)|TOBIT(XM_HM_AC_HALT)|TOBIT(XM_HM_AC_SWITCH_TO_MAINTENANCE),

    [XM_HM_EV_MEM_PROTECTION]=TOBIT(XM_HM_AC_IGNORE)|TOBIT(XM_HM_AC_HYPERVISOR_COLD_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_WARM_RESET)|TOBIT(XM_HM_AC_HALT)|TOBIT(XM_HM_AC_SWITCH_TO_MAINTENANCE),

    [XM_HM_EV_OVERRUN]=TOBIT(XM_HM_AC_IGNORE)|TOBIT(XM_HM_AC_HYPERVISOR_COLD_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_WARM_RESET)|TOBIT(XM_HM_AC_HALT)|TOBIT(XM_HM_AC_SWITCH_TO_MAINTENANCE),

    [XM_HM_EV_SCHED_ERROR]=TOBIT(XM_HM_AC_IGNORE)|TOBIT(XM_HM_AC_HYPERVISOR_COLD_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_WARM_RESET)|TOBIT(XM_HM_AC_HALT)|TOBIT(XM_HM_AC_SWITCH_TO_MAINTENANCE),

    [XM_HM_EV_WATCHDOG_TIMER]=TOBIT(XM_HM_AC_IGNORE)|TOBIT(XM_HM_AC_HYPERVISOR_COLD_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_WARM_RESET)|TOBIT(XM_HM_AC_SUSPEND)|TOBIT(XM_HM_AC_HALT)|TOBIT(XM_HM_AC_SWITCH_TO_MAINTENANCE),

    [XM_HM_EV_INCOMPATIBLE_INTERFACE]=TOBIT(XM_HM_AC_HYPERVISOR_COLD_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_WARM_RESET)|TOBIT(XM_HM_AC_HALT)|TOBIT(XM_HM_AC_SWITCH_TO_MAINTENANCE),
#ifdef CONFIG_ARM
    [XM_HM_EV_ARM_UNDEF_INSTR]=TOBIT(XM_HM_AC_IGNORE)|TOBIT(XM_HM_AC_HYPERVISOR_COLD_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_WARM_RESET)|TOBIT(XM_HM_AC_HALT)|TOBIT(XM_HM_AC_SWITCH_TO_MAINTENANCE),
    [XM_HM_EV_ARM_PREFETCH_ABORT]=TOBIT(XM_HM_AC_IGNORE)|TOBIT(XM_HM_AC_HYPERVISOR_COLD_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_WARM_RESET)|TOBIT(XM_HM_AC_HALT)|TOBIT(XM_HM_AC_SWITCH_TO_MAINTENANCE),
    [XM_HM_EV_ARM_DATA_ABORT]=TOBIT(XM_HM_AC_IGNORE)|TOBIT(XM_HM_AC_HYPERVISOR_COLD_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_WARM_RESET)|TOBIT(XM_HM_AC_HALT)|TOBIT(XM_HM_AC_SWITCH_TO_MAINTENANCE),
    [XM_HM_EV_ARM_DATA_ALIGNMENT_FAULT]=TOBIT(XM_HM_AC_IGNORE)|TOBIT(XM_HM_AC_HYPERVISOR_COLD_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_WARM_RESET)|TOBIT(XM_HM_AC_HALT)|TOBIT(XM_HM_AC_SWITCH_TO_MAINTENANCE),
    [XM_HM_EV_ARM_DATA_BACKGROUND_FAULT]=TOBIT(XM_HM_AC_IGNORE)|TOBIT(XM_HM_AC_HYPERVISOR_COLD_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_WARM_RESET)|TOBIT(XM_HM_AC_HALT)|TOBIT(XM_HM_AC_SWITCH_TO_MAINTENANCE),
    [XM_HM_EV_ARM_DATA_PERMISSION_FAULT]=TOBIT(XM_HM_AC_IGNORE)|TOBIT(XM_HM_AC_HYPERVISOR_COLD_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_WARM_RESET)|TOBIT(XM_HM_AC_HALT)|TOBIT(XM_HM_AC_SWITCH_TO_MAINTENANCE),
    [XM_HM_EV_ARM_INSTR_ALIGNMENT_FAULT]=TOBIT(XM_HM_AC_IGNORE)|TOBIT(XM_HM_AC_HYPERVISOR_COLD_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_WARM_RESET)|TOBIT(XM_HM_AC_HALT)|TOBIT(XM_HM_AC_SWITCH_TO_MAINTENANCE),
    [XM_HM_EV_ARM_INSTR_BACKGROUND_FAULT]=TOBIT(XM_HM_AC_IGNORE)|TOBIT(XM_HM_AC_HYPERVISOR_COLD_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_WARM_RESET)|TOBIT(XM_HM_AC_HALT)|TOBIT(XM_HM_AC_SWITCH_TO_MAINTENANCE),
    [XM_HM_EV_ARM_INSTR_PERMISSION_FAULT]=TOBIT(XM_HM_AC_IGNORE)|TOBIT(XM_HM_AC_HYPERVISOR_COLD_RESET)|TOBIT(XM_HM_AC_HYPERVISOR_WARM_RESET)|TOBIT(XM_HM_AC_HALT)|TOBIT(XM_HM_AC_SWITCH_TO_MAINTENANCE),
#endif

};

/* <track id="hm-part-default-conf"> */

static struct xmcHmSlot defaultPartHmTab[XM_HM_MAX_EVENTS]={
    [XM_HM_EV_INTERNAL_ERROR]={.action=XM_HM_AC_HALT, .log=XM_HM_LOG_ENABLED, },
    [XM_HM_EV_UNEXPECTED_TRAP]={.action=XM_HM_AC_HALT, .log=XM_HM_LOG_ENABLED, },
    [XM_HM_EV_PARTITION_UNRECOVERABLE]={.action=XM_HM_AC_HALT, .log=XM_HM_LOG_ENABLED, },
    [XM_HM_EV_PARTITION_ERROR]={.action=XM_HM_AC_HALT, .log=XM_HM_LOG_ENABLED, },
    [XM_HM_EV_PARTITION_INTEGRITY]={.action=XM_HM_AC_HALT, .log=XM_HM_LOG_ENABLED, },
    [XM_HM_EV_MEM_PROTECTION]={.action=XM_HM_AC_HALT, .log=XM_HM_LOG_ENABLED, },
    [XM_HM_EV_OVERRUN]={.action=XM_HM_AC_HALT, .log=XM_HM_LOG_ENABLED, },
    [XM_HM_EV_SCHED_ERROR]={.action=XM_HM_AC_HALT, .log=XM_HM_LOG_ENABLED, },
    [XM_HM_EV_WATCHDOG_TIMER]={.action=XM_HM_AC_HALT, .log=XM_HM_LOG_ENABLED, },
    [XM_HM_EV_INCOMPATIBLE_INTERFACE]={.action=XM_HM_AC_HALT, .log=XM_HM_LOG_ENABLED, },
#ifdef CONFIG_ARM
    [XM_HM_EV_ARM_UNDEF_INSTR]={.action=XM_HM_AC_HALT, .log=XM_HM_LOG_DISABLED, },
    [XM_HM_EV_ARM_PREFETCH_ABORT]={.action=XM_HM_AC_HALT, .log=XM_HM_LOG_DISABLED, },
    [XM_HM_EV_ARM_DATA_ABORT]={.action=XM_HM_AC_HALT, .log=XM_HM_LOG_DISABLED, },
    [XM_HM_EV_ARM_DATA_ALIGNMENT_FAULT]={.action=XM_HM_AC_HALT, .log=XM_HM_LOG_DISABLED, },
    [XM_HM_EV_ARM_DATA_BACKGROUND_FAULT]={.action=XM_HM_AC_HALT, .log=XM_HM_LOG_DISABLED, },
    [XM_HM_EV_ARM_DATA_PERMISSION_FAULT]={.action=XM_HM_AC_HALT, .log=XM_HM_LOG_DISABLED, },
    [XM_HM_EV_ARM_INSTR_ALIGNMENT_FAULT]={.action=XM_HM_AC_HALT, .log=XM_HM_LOG_DISABLED, },
    [XM_HM_EV_ARM_INSTR_BACKGROUND_FAULT]={.action=XM_HM_AC_HALT, .log=XM_HM_LOG_DISABLED, },
    [XM_HM_EV_ARM_INSTR_PERMISSION_FAULT]={.action=XM_HM_AC_HALT, .log=XM_HM_LOG_DISABLED, },
#endif

};
/* </track id="hm-part-default-conf"> */


static struct xmcHmSlot defaultHpvHmTab[XM_HM_MAX_EVENTS]={
    [XM_HM_EV_INTERNAL_ERROR]={.action=XM_HM_AC_HALT, .log=XM_HM_LOG_ENABLED, },
    [XM_HM_EV_UNEXPECTED_TRAP]={.action=XM_HM_AC_HALT, .log=XM_HM_LOG_ENABLED, },
    [XM_HM_EV_PARTITION_UNRECOVERABLE]={.action=XM_HM_AC_HALT, .log=XM_HM_LOG_ENABLED, },
    [XM_HM_EV_PARTITION_ERROR]={.action=XM_HM_AC_HALT, .log=XM_HM_LOG_ENABLED, },
    [XM_HM_EV_PARTITION_INTEGRITY]={.action=XM_HM_AC_HALT, .log=XM_HM_LOG_ENABLED, },
    [XM_HM_EV_MEM_PROTECTION]={.action=XM_HM_AC_HALT, .log=XM_HM_LOG_ENABLED, },
    [XM_HM_EV_OVERRUN]={.action=XM_HM_AC_HALT, .log=XM_HM_LOG_ENABLED, },
    [XM_HM_EV_SCHED_ERROR]={.action=XM_HM_AC_HALT, .log=XM_HM_LOG_ENABLED, },
    [XM_HM_EV_WATCHDOG_TIMER]={.action=XM_HM_AC_HALT, .log=XM_HM_LOG_ENABLED, },
    [XM_HM_EV_INCOMPATIBLE_INTERFACE]={.action=XM_HM_AC_HALT, .log=XM_HM_LOG_ENABLED, },
#ifdef CONFIG_ARM
    [XM_HM_EV_ARM_UNDEF_INSTR]={.action=XM_HM_AC_HALT, .log=XM_HM_LOG_ENABLED },
    [XM_HM_EV_ARM_PREFETCH_ABORT]={.action=XM_HM_AC_HALT, .log=XM_HM_LOG_ENABLED },
    [XM_HM_EV_ARM_DATA_ABORT]={.action=XM_HM_AC_HALT, .log=XM_HM_LOG_ENABLED },
    [XM_HM_EV_ARM_DATA_ALIGNMENT_FAULT]={.action=XM_HM_AC_HALT, .log=XM_HM_LOG_ENABLED },
    [XM_HM_EV_ARM_DATA_BACKGROUND_FAULT]={.action=XM_HM_AC_HALT, .log=XM_HM_LOG_ENABLED },
    [XM_HM_EV_ARM_DATA_PERMISSION_FAULT]={.action=XM_HM_AC_HALT, .log=XM_HM_LOG_ENABLED },
    [XM_HM_EV_ARM_INSTR_ALIGNMENT_FAULT]={.action=XM_HM_AC_HALT, .log=XM_HM_LOG_ENABLED },
    [XM_HM_EV_ARM_INSTR_BACKGROUND_FAULT]={.action=XM_HM_AC_HALT, .log=XM_HM_LOG_ENABLED },
    [XM_HM_EV_ARM_INSTR_PERMISSION_FAULT]={.action=XM_HM_AC_HALT, .log=XM_HM_LOG_ENABLED },
#endif

};
/* </track id="hm-xm-default-conf"> */

void SetupDefaultHpvHmActions(struct xmcHmSlot *hmTab) {
    memcpy(hmTab, defaultHpvHmTab, sizeof(struct xmcHmSlot)*XM_HM_MAX_EVENTS);
}

void SetupDefaultPartHmActions(struct xmcHmSlot *hmTab) {
    memcpy(hmTab, defaultPartHmTab, sizeof(struct xmcHmSlot)*XM_HM_MAX_EVENTS);
}


void HmHpvIsActionPermittedOnEvent(int event, int action, int line) {
    if (!(hmHpvEventsAndActions[event]&TOBIT(action)))
	LineError(line, "Action \"%s\" on event \"%s\" is not permitted", hmActions[action], hmEvents[event]);
}

void HmPartIsActionPermittedOnEvent(int event, int action, int line) {
    if (!(hmPartEventsAndActions[event]&TOBIT(action)))
	LineError(line, "Action \"%s\" on event \"%s\" is not permitted", hmActions[action], hmEvents[event]);
}

void HmCheckExistMaintenancePlan(void) {
    int e, i, maintenance=0;
    // Are there any maintenance action?
    for (e=0;e<XM_HM_MAX_EVENTS; e++)
        if(xmc.hpv.hmTab[e].action==XM_HM_AC_SWITCH_TO_MAINTENANCE)
            maintenance=1;
    
    for (e=0; e<xmc.noPartitions; e++)
        for (i=0; i<XM_HM_MAX_EVENTS; i++)
            if (xmcPartitionTab[e].hmTab[i].action==XM_HM_AC_SWITCH_TO_MAINTENANCE)
                maintenance=1;       

    if (maintenance)
        // Is there a maintenance plan?
        for (e=0; e<xmc.hpv.noCpus; e++)
            if(xmc.hpv.cpuTab[e].noSchedCyclicPlans<2)
                LineError(xmcNoL.hpv.cpuTab[e].id, "Although required, a maintenance plan is not defined for CPU \"%d\"", xmc.hpv.cpuTab[e].id);
}
